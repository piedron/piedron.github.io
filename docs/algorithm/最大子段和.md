---
title: 最大子段和
tags: 

  - 分治算法

  - C

  - PTA

created: 2020/2/19
---

给定*K*个整数组成的序列{ *N*1, *N*2, ..., *N<sup>K</sup>* }，“连续子列”被定义为{ *N<sup>i</sup>*, N<sup>i+1</sup>, ..., *N*<sup>j</sup>}，其中 1≤*i*≤*j*≤*K*。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 <!-- more -->

## 1. 题目：

关于最大子段和问题这边复制[PTA](<https://pintia.cn/problem-sets/15/problems/709>)中题意描述：

> 给定*K*个整数组成的序列{ *N*1, *N*2, ..., *N<sup>K</sup>* }，“连续子列”被定义为{ *N<sup>i</sup>*, N<sup>i+1</sup>, ..., *N*<sup>j</sup>}，其中 1≤*i*≤*j*≤*K*。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。
>
> 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：
>
> - 数据1：与样例等价，测试基本正确性；
>- 数据2：10<sup>2</sup>个随机整数
> - 数据3：10<sup>3</sup>个随机整数；
> - 数据4：10<sup>4</sup>个随机整数；
> - 数据5：10<sup>5</sup>个随机整数；
> 
> ### 输入格式:
>
> 输入第1行给出正整数*K* (≤100000)；第2行给出*K*个整数，其间以空格分隔。
>
> ### 输出格式:
>
> 在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。
>
> ### 输入样例:
>
> ```
>6
> -2 11 -4 13 -5 -2
> ```
> 
> ### 输出样例
>
> ```
>20
> ```

## 2. 三种解法：

> ### (1). 简单枚举法：
>
> 描述：即选一个起点，选一个终点，然后从起点到终点一直加得到一个和，然后在每得到一个和就和当前最大值比较直至所有的情况都遍历完，代码如下：
>
> ```c
> #include<stdio.h>
> int a[100001]={0};
> int main(void)
> {
>     int i,n,j,k,max,sum=0;
>     scanf("%d",&n);
>     for(i=0;i<n;i++)
>         scanf("%d",a+i);
>     max=a[0]; 
>     for(i=0;i<n;i++)  //起点
>     {
>         for(j=i;j<n;j++)  //终点
>         {
>             sum=0;
>             for(k=i;k<=j;k++)  //求和
>             {
>                 sum+=a[k];
>             }
>             if(sum>max)  //比较
>                 max=sum;
>         }
>     }
>     if(max<0) max=0;  //控制为0及0以上
>     printf("%d",max);
>     return 0;
> } 
> ```
>
> 算法复杂度为O(n<sup>3</sup>)，甚至可以发现在PTA 的OJ上当数据为10000时为运行超时，因此这种解法显然行不通

​	

------

> ### 续(1)改进解法：
>
> 这里通过第二层循环可直接进行求和，不必再起一个循环，依次比较的加和顺序是一样的，只是在第二层循环就可以实现累积加和，也就是不必每次赋sum为0然后再起一个循环重新算，代码如下：
>
> ```c
> #include<stdio.h>
> int a[100001]={0};
> int main(void)
> {
>     int i,n,j,max,sum=0;
>     scanf("%d",&n);
>     for(i=0;i<n;i++)
>         scanf("%d",a+i);
>     max=a[0]; 
>     for(i=0;i<n;i++)
>     {
>         sum=0;   //每次累积加和前赋值为0
>         for(j=i;j<n;j++)
>         {
>             sum+=a[j];   //分次比较累积的和
>             if(sum>max)
>                 max=sum;
>         }
>     }
>     if(max<0) max=0;
>     printf("%d",max);
>     return 0;
> }
> ```
>
> 该算法时间复杂度为O(n<sup>2</sup>)，比上述算法要好一点，但远远不够，不过这里在PTA OJ上是可以通过的

------

> ### (2).  分治法递归求解：
>
> 描述：所谓分治法简单来讲就是将一个问题规模比较大的问题分为若干个问题规模较小的子问题，然后以同样的方式解决子问题，这也就是递归的思想，直至问题规模足够小至可以直接解决时则为递归终止条件，这里，揭发思想如下，将一个序列从中间分为两段，则其最大子段和不过分为如下三种情况：
>
> 1. 左半段的最大子段和，这里也就是将问题规模缩小一半了，也就是递归调用的过程
> 2. 右半段的最大子段和，同上句话
> 3. 设i为左半段一点，j为右半段一点，则最大子段和位于区间[i,j]，这里不同于递归调用，需进行详细计算，先计算从中点到左半段一点i的最大值，再计算中点到右半段一点j的最大值，然后求和得到这种情况可能的最大值
>
> 这样分情况即可，前两种情况递归调用，后一种计算，然后比较后返回值即可
>
> ```c
> #include<stdio.h>
> int a[1000005]={0};
> int maxSub(int left,int right)
> {
>     int mid=(right+left)/2,leftsum,rightsum,sum=0,leftmax,rightmax,max,i;
>     if(left==right) return a[left]>0?a[left]:0; //递归终止条件，此时若大于0则返回，若小于0则为0
>     else{
>         leftsum=maxSub(left,mid);  //计算第一种可能的情况
>         rightsum=maxSub(mid+1,right);  //第二种
>         leftmax=a[left];  
>         for(i=mid;i>=left;i--)  //计算左半段最大值
>         {
>             sum+=a[i];
>             if(sum>leftmax)
>                 leftmax=sum;
>         }
>         rightmax=a[mid+1];
>         sum=0;
>         for(i=mid+1;i<=right;i++)  //计算右半段最大值
>         {
>             sum+=a[i];
>             if(rightmax<sum)
>                 rightmax=sum;
> 
>         }
>         max=leftmax+rightmax;  //第三种可能的值
>         if(max<leftsum)  //比较然后确定哪种情况
>             max=leftsum;
>         if(max<rightsum)  //注意这里不是else if，因为两种可能同时成立，若同时成立，则max值先被赋为左，后被赋为右，或直接被赋为左
>             max=rightsum;
>         if(max<0)  max=0;
>         return max;
>     }
> }
> int main(void)
> {
>     int n,i;
>     scanf("%d",&n);
>     for(i=0;i<n;i++)
>         scanf("%d",a+i);
>     printf("%d",maxSub(0,n-1));
>     return 0;
> }
> ```
>
> 该算法由于使用的是二分的递归，则时间复杂度为O(n log(n))，相对于上述两种算法均有改进

------

> ### (3).  动态规划算法：
>
> 描述：最大子段和即为n个数中k个连续序列的最大值，而n个数的最大子段和又可由n-1的最大子段和推出，即设b[i]=max(a[0],……a[i]) (0<=i<=n-1)，则可知若b[i]大于0则b[i+1]=b[i]+a[i+1]，否则为a[i+1]，根据该思想从b[0]=a[0]开始可仅用一层循环递推就算出了结果，代码如下：
>
> ```c
> #include<stdio.h>
> int a[100005]={0};
> int b[100005]={0};
> int main(void)
> {
>     int i,max,n;
>     scanf("%d",&n);
>     for(i=0;i<n;i++)
>         scanf("%d",a+i);
>     max=b[0]=a[0];
>     for(i=0;i<n-1;i++)
>     {
>         if(b[i]>0)  //递推过程
>             b[i+1]=b[i]+a[i+1];
>         else
>             b[i+1]=a[i+1];
>         if(max<b[i+1])  //求最大
>             max=b[i+1];
>     }
>     printf("%d",max);
>     return 0;
> }
> ```
>
> 该算法时间复杂度为O(n)，是最大子段和求解的这几种算法中效率最高的算法

------

如上代码均经过[PTA](<https://pintia.cn/problem-sets/15/problems/709>) OJ测试过，除了第一种算法由于效率过低在数据过多时会超时，因此没通过，大家也可以在PTA上进行代码编写和测试。

​          -------------------------------------------------------------***The End***----------------------------------------------------------------------

![](https://www.piedron.cn/images/bg1.jpg)