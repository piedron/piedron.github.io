---
title: 分治-盒分形输出问题
created: 2020/2/25
tags:

  - 分治算法

  - C

  - PTA
---
分形，具有以非整数维形式充填空间的形态特征。通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质，这里介绍了分治法利用递归来解决盒分形输出问题。 <!-- more -->

## 前言(问题描述):

该问题引自[PTA **分形的递归输出**](<https://pintia.cn/problem-sets/1231397731926429696/problems/1231459965276934144>)

> 分形，具有以非整数维形式充填空间的形态特征。通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。 <!-- more -->
>
> 一个盒状分形定义如下： 度为1的盒分形为：
>
> ```
> X
> ```
>
> 度为2的盒分形为：
>
> ```
> X X
>  X
> X X  
> ```
>
> 依次类推，如果B(n-1)表示n-1度的盒分形，则n度的盒分形递归定义如下：
>
> ```
> B(n - 1)        B(n - 1)
> 
>         B(n - 1)
> 
> B(n - 1)        B(n - 1)
> ```
>
> 请画出度为n的盒分形的图形
>
> 具体可参加上述链接

------

> ## 分治法求解：
>
> 题述已经表明了递归的过程，也就是将大一级的图形分为5个小一级的图形输出，也就是分为五块输出，但关键是这五块不能实时选位置输出，这也就是关键所在，直接没法把这个问题用递归的结构描述出来，因此关键就在于转换为把所有要输出的字符存到一个足够大的字符数组里，这样每次递归调用的过程即为为一个字符变量赋值的过程，因此算法可描述为：
>
> n级的从左上角坐标(x,y)开始绘制的盒分形分解为5个n-1级的子问题
>
> - 左上角：n-1级的左上角坐标为(x,y)的问题
> - 右上角：n-1级的左上角坐标为(x+2*size,y)的子问题
> - 中央：n-1级的左上角坐标为(x+size,y+size)的子问题
> - 左下角：n-1级的左上角坐标为(x,y+2*size)的子问题
> - 右下角：n-1级的左上角坐标为(x+2*size,y+2 *size)的子问题
>
> ```c
> #include<stdio.h>
> #define Max 730
> #include<math.h>
> char mat[Max][Max]={' '};
> void toDraw(int x,int y,int n)
> {
> 	int m=(int)pow(3,n-2);  //该层次下一子层的盒分形的size 
> 	if(n==1) mat[x][y]='X';
> 	else
> 	{
> 		toDraw(x,y,n-1);  //绘制左上角的盒分形
> 		toDraw(x,y+2*m,n-1);  //绘制右上角的盒分形
> 		toDraw(x+m,y+m,n-1);  //绘制中心盒分形
> 		toDraw(x+2*m,y,n-1);  //绘制左下角盒分形
> 		toDraw(x+2*m,y+2*m,n-1);  //绘制右下角盒分形 
> 	}
> }
> int main(void)
> {
> 	int n,size,i,j;
>     while(scanf("%d",&n))
>     {
> 		if(n==-1)
> 			break;
> 		size=(int)pow(3,n-1);
> 		for(i=0;i<size;i++)
> 		{
> 			for(j=0;j<size;j++)
> 				mat[i][j]=' ';
> 		}
> 		toDraw(0,0,n);  
> 		for(i=0;i<size;i++)
> 			mat[i][size]='\0';    
> 		for(i=0;i<size;i++)
> 			puts(mat[i]);    
> 		printf("-\n");
> 	}
> 	return 0;
> } 
> ```
>
> 将来在求解此类屏幕输出问题时，要考虑到字符数组的利用，原实时输出过程即为对字符数组的赋值过程，从而实现递归调用来解题

------

> ## 优化求解
>
> 这里所说的优化，实际还是使用递归的思想，只是对于这种需要处理多组数据的题目，由于递归算大问题时同时计算了小的若干个子问题，因此就像之前解决[放苹果问题](https://www.piedron.cn/2020/02/25/分治-放苹果问题/)那样，可以一次性把稍大规模的大问题直接算出来，并用数组保存下来，这样，多组数据再多再大，程序也只算了一遍，这样可以在一定程度上提高效率，避免在面对多组输入数据时重复或多次计算重复的子问题。
>
> ```c
> #include<stdio.h>
> #define Max 730
> #include<math.h>
> char mat[Max][Max]={' '};
> int h[8]={1};
> void toDraw(int x,int y,int n)
> {
> 	int m=h[n-2];  //该层次下一子层的盒分形的size
> 	if(n==1) mat[x][y]='X';
> 	else
> 	{
> 		toDraw(x,y,n-1);  //绘制左上角的盒分形
> 		toDraw(x,y+2*m,n-1);  //绘制右上角的盒分形
> 		toDraw(x+m,y+m,n-1);  //绘制中心盒分形
> 		toDraw(x+2*m,y,n-1);  //绘制左下角盒分形
> 		toDraw(x+2*m,y+2*m,n-1);  //绘制右下角盒分形
> 	}
> }
> int main(void)
> {
> 	int n,i,j;
>     for(i=1;i<7;i++)  //利用数组累乘计算size
>     {
>         h[i]=h[i-1]*3;
>     }
>     for(i=0;i<h[6];i++)  //仅初始化一次
> 	{
> 		for(j=0;j<h[6];j++)
> 			mat[i][j]=' ';
> 	}
>     toDraw(0,0,7);    //仅求一次最大问题
>     while(scanf("%d",&n))
>     {
> 		if(n==-1)
> 			break;
> 		for(i=0;i<h[n-1];i++)
>         {
>             for(j=0;j<h[n-1];j++)
>             {
>                 putchar(mat[i][j]);   //不同的子问题都只是从最大的问题中抽取递归时已经计算好的子问题来输出
>             }
>             putchar('\n');
>         }
>         putchar('-');
> 		putchar('\n');
> 	}
> 	return 0;
> }
> 
> 
> ```
>
> 

------

-------------------------------------------------------------***The End***----------------------------------------------------------------------

![](https://www.piedron.cn/images/bg6.jpg)