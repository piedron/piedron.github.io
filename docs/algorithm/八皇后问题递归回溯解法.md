---
title: 回溯-八皇后问题递归解法（含c解法和显示所有情况的java解法）

created: 2020/3/1

updated: 2020/3/1

tags:

  - 回溯算法

  - C

  - Java
---
[八皇后](https://baike.baidu.com/item/八皇后)问题，是[回溯算法](https://baike.baidu.com/item/回溯算法/9258495)的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的[国际象棋](https://baike.baidu.com/item/国际象棋/80888)上摆放八个[皇后](https://baike.baidu.com/item/皇后/15860305)，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<!-- more -->

回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯[条件](https://baike.baidu.com/item/条件/1783021)的某个[状态](https://baike.baidu.com/item/状态/33204)的点称为“回溯点”。

------

> 算法描述：基本思想就是采用回溯的思想，从第一行开始，对每一行的各列进行测试，若该列可以，则开始下一行的各列测试，直至到第8行一种情况就测试完了，若中途在某一行所有列均不可取，则代表上一行的已选的那一列便不可取，故要在上一行的后续列中选，这也就是回溯点，会到上一级的循环中选下一列，然后再到下一级重新测试直至一种情况完整测试完即可，若一种情况测试完了，那么就会回到上一级进行后续列的测试，直至所有情况测试完即可。下述代码中注释较为详细，这里就不赘述了。
>
> {% tabs 八皇后问题递归回溯解法, 2 %}
> <!-- tab C解法（只含种类数） -->
>
> ```c
> //递归调用回溯法解决八皇后问题
> #include<stdio.h>  //尽量数组下标从1开始，因为这样不容易出错
> int queen[9]={-1,-1,-1,-1,-1,-1,-1,-1,-1};  //每行的皇后放的列数，-1代表还未放
> int count=0;  //全局变量用来计算有多少中情况
> int available(int row,int col)  //判断改行该列的皇后放置的位置是否不可取
> {
> 	for(int i=1;i<row;i++)  //这里注意row和col以及数组下标均从1开始的
> 	{
> 		if(col==queen[i])  //代表该列与其他行有冲突
> 			return 0;
> 		if(col-queen[i]==row-i) //代表主对角线有冲突
> 			return 0;
> 		if(col-queen[i]+row-i==0)  //代表副对角线有冲突
> 			return 0;
> 		//注意主对角线与副对角线的判别方法
> 		//主对角线可以用一个点的横纵坐标之差与另一点想等来判断，也可以横-横=纵-纵
> 		//但副对角线只能是横-横+纵-纵=0，而不能简单的对照着主对角线的条件来判断副对角线
> 		//我该热烈的庆祝我在副对角线条件入坑了
> 	}
> 	return 1;
> }
> void placequeen(int row)
> {
> 	for(int col=1;col<=8;col++)  //对该行的每一列测试
> 	{
> 		if(available(row,col))
> 		{
> 			queen[row]=col;
> 			if(row==8)
> 			{
> 				count++;  //一种完整情况遍历完则种数加1
> 				return;  //返回到上一级调用在循环中测试上一行的下一列
> 			}
> 			else //若一种情况还未结束，则开始调用放置下一行
> 				placequeen(row+1);
> 		}
> 	}
> 	//若改行每列都行不通，则要回溯到上一级，并抹去上一级的放置列数，重回上一级的列数循环开始下一行的测试
> 	//若此处数组下标从0开始的，则要注意下标的越界访问，因为最后函数总调用出口是在row=1的时候在这return的，但-1的下标是不存在的
> 	//也就是数组下标从0开始，在这每次都得row-2才是上一行的，所以从数组下标1开始则有0，但从0开始则要有-1，加个row>1即可
> 	queen[row-1]=-1;  //抹去上一级的列数
> 	return;   //返回上一级试下一列
> }
> int main(void)
> {
> 	placequeen(1);  //从第一行开始测试
> 	printf("%d",count);
> 	return 0;
> }
> 
> ```
>
> <!-- endtab -->
> <!-- tab Java解法（包含显示所有情况）-->
>
> ```java
> package c4;
> 
> public class q7 {
> 	public static int[] queen= {0,0,0,0,0,0,0,0,0}; //代表每行的皇后存放的列数，0代表未放
> 	public static int count=0;
> 	public static char[][] board=new char[9][9];  //为简便运算，下标均从1开始
> 	//注意为了简便运算少传参，故采用全局变量的格式，但由于静态函数只能访问静态域以及调用静态函数，故由于main函数接口为静态
> 	//故均采用静态域与静态函数
> 	public static void init()  //为整个输出棋盘初始化为空格，即未放皇后
> 	{
> 		for(int i=1;i<=8;i++)
> 		{
> 			for(int j=1;j<=8;j++)
> 			{
> 				board[i][j]=' ';
> 			}
> 		}
> 	}
> 	public static void print()  //输出一种情况函数，每次当row到8时也就是一种情况测试完后就输出
> 	{
> 		for(int i=1;i<=8;i++)
> 		{
> 			System.out.println("+ - + - + - + - + - + - + - + - +");
> 			for(int j=1;j<=8;j++)
> 			{
> 				System.out.print("|"+" "+board[i][j]+" ");
> 			}
> 			System.out.println("|");
> 		}
> 		System.out.println("+ - + - + - + - + - + - + - + - +\n");
> 	}
> 	public static boolean available(int row,int col) //判断将要放的位置是否可取即是否与已放存在冲突
> 	{
> 		for(int i=1;i<row;i++)
> 		{
> 			if(col==queen[i])  return false;  //与某一列存在冲突
> 			if(col-row==queen[i]-i)  return false; //与某一主对角线存在冲突
> 			if(col-queen[i]+row-i==0) return false;  //与某一副对角线存在冲突
> 		}
> 		return true;
> 	}
> 	public static void placequeen(int row) //存放皇后的回溯递归函数
> 	{
> 		for(int col=1;col<=8;col++) //对该行的每一列进行测试
> 		{
> 			if(available(row,col)) //若该列可取
> 			{
> 				queen[row]=col;  //存储存放位置
> 				board[row][col]='Q';  //棋盘更新皇后位置
> 				if(row==8)  //若一种情况测试结束
> 				{
> 					count++;  //则加1
> 					print();  //则输出棋盘
> 					board[row-1][queen[row-1]]=' ';  //输出后要回溯到上一级
> 					board[row][col]=' ';//因此上一级和当前级均要重新存放，因此这两行存放皇后的地方都要更新为空
> 					return;  //回溯到上一级循环测试后续列数
> 				}
> 				else  //若未结束则测试下一级
> 					placequeen(row+1);
> 			}
> 		}
> 		//若改行所有列均不可取，则代表上一行列数选取不合理，则要回溯到上一级循环测试后续列数
> 		board[row-1][queen[row-1]]=' ';  //因当前行为存放过，故只需更新上一级皇后存放位置为空
> 		queen[row-1]=0;
> 		return;  
> 	}
> 	public static void main(String[] args)
> 	{
> 		init();  //注意由于解决问题时采用的是回溯递归的算法，因此不能再输出一次后全部初始化，因为输出一次后
> 		//要继续从上一级循环测试其他列，故除这两行的其他行都未变，故需在回溯点时只更新当前行和上一行即可
> 		placequeen(1);
> 		System.out.printf("八皇后问题总共有%d中解法",count);
> 	}
> }
> 
> ```
>
> <!-- endtab -->
> {% endtabs %}

------

{% cq %}
后述

关于八皇后的问题，还有其他解法，有递归转换来的迭代法，迭代法思想是与递归一致的，但表达形式却远不如递归，代码看起来不好理解，因此这里也就不介绍了，主要还是自己懒，还有就是根据递归的特性，其本身就是栈的使用，故可手动用栈来模仿函数的递归调用，也与递归一致，还有就是万恶的枚举法，刚开始我在想我连枚举法都想不出来该咋做，因为是在太麻烦了，麻烦到我刚开始就不不敢想，看看别人列的八层循环我也是一眼都不瞄一下就走了，但说来说去，最重要的还是用递归法回溯的算法思想来解决八皇后问题时最好不过了，掌握这个也就该知足了。知足才能常乐嘛！

{% endcq %} 

已完结……

![](https://www.piedron.cn/images/bg3.jpg)