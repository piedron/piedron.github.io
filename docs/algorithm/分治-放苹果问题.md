---
title: 分治-放苹果问题
meta:

  - name: description

    content: 分治-放苹果

  - name: keywords

    content: 分治，放苹果

created: 2020/2/23

updated: 2020/2/23

tags:

  - 分治算法

  - C

  - POJ
---

分治法以及优化版的递推法解决POJ-1664的放苹果问题。  <!-- more -->

## 前言（问题描述）：

该问题引自[POJ-1664 **放苹果**](<http://poj.org/problem?id=1664>)

> 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。
>
> ### 输入格式
>
> 第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1<=M，N<=10。
>
> ### 输出格式
>
> 对输入的每组数据M和N，用一行输出相应的K。  <!-- more -->
>
> ### 输入样例
>
> ```
> 1
> 7 3
> ```
>
> ### 输出样例
>
> ```
> 8
> ```

------

> ## 分治法递归求解
>
> 该问题分治法解决思想于正整数划分相似，即将问题重新描述为将n个苹果分到不多于m个盘子的分类数，这是分治法求解的关键，因为只有把问题描述为这样，才能将问题通过总结一些样例很好的分解为更小的子问题，才能分治法递归求解
>
> 即描述为这样：
>
> - 当n=1或者m=1时，直接放就可以了，就只有一种
> - 当n<m时，也就是放到n个盘子里去，相当于把n个苹果放到n个盘子里
> - 当n>m时，可分为两种情况：
>   1. 确定要把n个苹果放到m个盘子里，则m个盘子里都要有一个，那么还剩下n-m个苹果，然后问题就归结为将剩余n-m个苹果分到不多于m个盘子里的子问题
>   2. 除去确定分到m个盘子里，另一种就是分到不多于m-1个盘子里
>
> ```c
> #include<stdio.h>
> int place(n,m)
> {
>     if(n<=1||m<=1)  return 1;
>     else if(n<m)  return place(n,n);
>     else  return place(n-m,m)+place(n,m-1);
> }
> int main(void)
> {
> 	int t,n,m,i;
>     scanf("%d",&t);
>     for(i=0;i<t;i++)
>     {
>         scanf("%d %d",&n,&m);
>         printf("%d\n",place(n,m));
>     }
>     return 0;
> }
> ```
>
> 该算法存在重复计算子问题的过程，而且针对于POJ上的问题描述，此处需要多次计算该过程，因此会更多的计算一些已经计算过的子问题，因此可采用数组存这些子问题的解，然后递推求解且能重复利用这些子问题的解，从而增快效率

------

> ## 数组递推法求解
>
> 当问题描述为这样时，同时还能递推求解
>
> - 当n=1或者m=1时，直接放就可以了，就只有一种
> - 当n<m时，也就是放到n个盘子里去，相当于把n个苹果放到n个盘子里
> - 当n>m时，可分为两种情况：
>   1. 确定要把n个苹果放到m个盘子里，则m个盘子里都要有一个，那么还剩下n-m个苹果，然后问题就归结为将剩余n-m个苹果分到不多于m个盘子里的子问题
>   2. 除去确定分到m个盘子里，另一种就是分到不多于m-1个盘子里
>
> 也就是这样，用place[n] [m]来表示为把n个苹果放到不多于m个盘子里的情况数
>
> ```c
> #include<stdio.h>
> #define M 11
> int place[M][M]={0};
> int main(void)
> {
> 	int i,j,t,m,n;
> 	scanf("%d",&t);
> 	for(i=0;i<M;i++)
> 	{
> 		for(j=0;j<M;j++)
> 		{
> 			if(i<=1||j<=1)
> 				place[i][j]=1;
> 			else if(i<j)
> 				place[i][j]=place[i][i];
> 			else
> 				place[i][j]=place[i-j][j]+place[i][j-1];
> 		}
> 	}
> 	for(i=0;i<t;i++)
> 	{
> 		scanf("%d %d",&n,&m);
> 		printf("%d\n",place[n][m]);
> 	}
> 	return 0;
> }
> ```

------

​          -------------------------------------------------------------***The End***----------------------------------------------------------------------

![](https://www.piedron.cn/images/bg9.jpg)